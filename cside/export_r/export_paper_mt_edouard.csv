#,key,Title,Link,Preview,Abstract,Year,Bibtex
1,paper_1,"A graph transformation-based approach for applying MDA to SOA",http://www.scopus.com/inward/record.url?eid=2-s2.0-77949810823&partnerID=40&md5=bd3a7e885e4be05ab4e2a8ba4dc0b8c8,"<b>Authors:</b><br/>Taghizadeh F., Taghizadeh S.R. <br/><b>Key words:</b><br/>Aspects and Jini; MDA; Middleware transparency; Model transformation; SDM; SOA <br/>","Although Model Driven Architecture has taken successful steps toward model-based software development, this approach still faces complex situations and ambiguous questions while applying to real world software systems. One of these questions - which has taken the most interest and focus - is how model transforms between different abstraction levels, MDA proposes. In this paper, we propose an approach based on Story Driven Modeling and Aspect Oriented Programming to ease these transformations. Service Oriented Architecture is taken as the target model to test the proposed mechanism in a functional system. _ 2009 IEEE.",2009,
2,paper_2,"A metamodeling approach to transform uml 2.0 sequence diagrams to petri nets",http://www.scopus.com/inward/record.url?eid=2-s2.0-62849114190&partnerID=40&md5=8326193c3aec58beb72a0659f9274efc,"<b>Authors:</b><br/>Dos Santos Soares M., Vrancken J. <br/><b>Key words:</b><br/>Formal Methods; Model Driven Engineering; Model Transformations; Petri nets; Sequence Diagrams <br/>","The paper presents transformations from UML 2.0 Sequence Diagrams to Time Petri nets with inhibitor arcs. The transformation is not restricted to messages calls and responses, hit also to some of the new Sequence Diagrams operators. This model-to-model transformation is based on metamodels and is tiseful to improve semantics, as Petri nets can be executed by simtilation and formally proved. The advantages of this mtilti-formalism approach are that different views are represented, complex systems development is done based on several levels of detail, and complexity is managed with abstraction and modtilarization.",2008,
3,paper_3,"A model driven engineering design approach for developing multi-platform user interfaces",http://www.scopus.com/inward/record.url?eid=2-s2.0-77954736681&partnerID=40&md5=74244f76e8f605edde6c0a0367af1e4f,"<b>Authors:</b><br/>Saleh E., Kamel A., Fahmy A. <br/><b>Key words:</b><br/>ConcurTaskTrees; Dialog model; Model-based user interface design; StateCharts; UsiXML <br/>","The wide variety of interactive devices and modalities an interactive system must support has created a big challenge in designing a multi-platform user interface and poses a number of issues for the design cycle of interactive systems. Model-Based User Interface Design (MBUID) approaches can provide a useful support in addressing this problem. In MBUID the user interface is described using various models; each describes a different facet of the user interface. Our methodology is based on task models that are attributed to derive a dialog model, from which different concrete models with different appearances can be generated. This paper presents a semi-automatic Model-Based transformational methodology for multi-platform user interface (MPUI) design. The proposed methodology puts dialog modeling in the center of the design process. A core model is integrated in the design process namely our Dialog-States Model (DSM); which represents our initial step to adapting to multiple target platforms by assigning multiple Dialog- State models to the same task model. A multi-step reification process will be taken from abstract models to more concrete models until reaching a final user interface customized according to the target platform.",2010,
4,paper_4,"autoHMI: a model driven software engineering approach for HMIs in process industries",http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=5952755,"<b>Authors:</b><br/>Urbas, L., Doherr, F. <br/>","In process industries the Human Machine Interfaces (HMI) for the Supervisory Control Systems are built at the very end of the planning phase because of the many interdependencies of engineering data. These HMIs consist of a hierarchy of graphical displays that illustrate the chemical process and its automation system. Today, these displays are derived manually from the plant\'s piping and instrumentation diagrams (P&ID) and other sources. We present a model driven software engineering solution to automatically generate the HMI directly from engineering data. At the core of the algorithm there are two models - a concept and task model describing the process and its structure, and an abstract HMI-model describing the interaction space. This article describes the design and structure of these models as well as the chain of transformations that are necessary to generate supervisory control HMIs for the process industries. A case study shows the scope and limitations of this approach.",2011,
5,paper_6,"A semi-automatic approach for bridging DSMLs with UML",http://www.scopus.com/inward/record.url?eid=2-s2.0-84886390835&partnerID=40&md5=a3ca4ddca108092ed29f4b929028ed54,"<b>Authors:</b><br/>Wimmer M. <br/><b>Key words:</b><br/>Information modelling; Open systems; Software tools <br/>","Purpose - The definition of modeling languages is a key-prerequisite for model-driven engineering. In this respect, Domain-Specific Modeling Languages (DSMLs) defined from scratch in terms of metamodels and the extension of Unified Modeling Language (UML) by profiles are the proposed options. For interoperability reasons, however, the need arises to bridge modeling languages originally defined as DSMLs to UML. Therefore, the paper aims to propose a semi-automatic approach for bridging DSMLs and UML by employing model-driven techniques. Design/methodology/approach - The paper discusses problems of the ad hoc integration of DSMLs and UML and from this discussion a systematic and semi-automatic integration approach consisting of two phases is derived. In the first phase, the correspondences between the modeling concepts of the DSML and UML are defined manually. In the second phase, these correspondences are used for automatically producing UML profiles to represent the domain-specific modeling concepts in UML and model transformations for transforming DSML models to UML models and vice versa. The paper presents the ideas within a case study for bridging ComputerAssociate\'s DSML of the AllFusion Gen CASE tool with IBM\'s Rational Software Modeler for UML. Findings - The ad hoc definition of UML profiles and model transformations for achieving interoperability is typically a tedious and error-prone task. By employing a semi-automatic approach one gains several advantages. First, the integrator only has to deal with the correspondences between the DSML and UML on a conceptual level. Second, all repetitive integration tasks are automated by using model transformations. Third, well-defined guidelines support the systematic and comprehensible integration. Research limitations/implications - The paper focuses on the integrating direction DSMLs to UML, but not on how to derive a DSML defined in terms of a metamodel from a UML profile. Originality/value - Although, DSMLs defined as metamodels and UML profiles are frequently applied in practice, only few attempts have been made to provide interoperability between these two worlds. The contribution of this paper is to integrate the so far competing worlds of DSMLs and UML by proposing a semi-automatic approach, which allows exchanging models between these two worlds without loss of information. _ Emerald Group Publishing Limited.",2009,
6,paper_9,"Automated middleware QoS configuration techniques using model transformations",http://www.scopus.com/inward/record.url?eid=2-s2.0-52049106833&partnerID=40&md5=285b91b650436f428cbc92d0f33fdc0d,"<b>Authors:</b><br/>Kavimandan A., Gokhale A. <br/>","This paper provides following three contributions to the study of developing and applying model driven engineering (MDE) techniques to Quality of Service (QoS) configuration of distributed real-time and embedded (DRE) systems. First, we describe the challenges associated with mapping domain-level QoS policies of DRE systems to middleware configuration space. Second, we discuss a domain specific modeling language (DSML) to capture QoS requirements of DRE system at a higher level of abstraction, simplifying the system QoS specification process. Third, we describe model transformations to automate the mapping of domain-specific QoS requirements.Our results indicate that our approach provides significant benefits in terms of productivity, scalability, reusability and automation of middleware QoS mapping compared to traditional QoS configuration techniques for publish/subscribe-based DRE systems. _2008 IEEE.",2007,
7,paper_10,"Automatic prototyping in model-driven game development",http://www.scopus.com/inward/record.url?eid=2-s2.0-67949106324&partnerID=40&md5=5873243a917bb524b551c65338a3ea36,"<b>Authors:</b><br/>Reyno E.M., Carsi Cubel J. <br/><b>Key words:</b><br/>Game development; Game prototyping; Model-driven engineering; Model-driven game development <br/>","Model-driven game development (MDGD) is an emerging paradigm where models become first-order elements in game development, maintenance, and evolution. In this article, we present a first approach to 2D platform game prototyping automatization through the use of model-driven engineering (MDE). Platform-independent models (PIM) define the structure and the behavior of the games and a platform-specific model (PSM) describes the game control mapping. Automatic MOFscript transformations from these models generate the software prototype code in C++. As an example, Bubble Bobble has been prototyped in a few hours following the MDGD approach. The resulting code generation represents 93% of the game prototype.",2009,
8,paper_11,"Bridging WebML to model-driven engineering: From document type definitions to meta object facility",http://www.scopus.com/inward/record.url?eid=2-s2.0-34250784598&partnerID=40&md5=22d2a2cdc74c7c7665d20835c16325ee,"<b>Authors:</b><br/>Schauerhuber A., Wimmer M., Kapsammer E., Schwinger W., Retschitzegger W. <br/>","Meta-models are a prerequisite for model-driven engineering (MDE) in general and consequently for model-driven web engineering in particular. Various web modelling languages, however, are not based on meta-models and standards, like object management group\'s prominent meta object facility (MOF). Instead they define proprietary languages rather focused on notational aspects. Thus, MDE techniques and tools cannot be deployed for such languages preventing to exploit the full potential of MDE in terms of standardised storage, exchange and transformation of models. The WebML web modelling language is one example that does not yet rely on an explicit meta-model in the sense of MDE. Instead, it is defined in terms of a document type definition (DTD), and implicitly within the accompanying tool. Code generation then has to rely on model-to-code transformations based of extensible stylesheet language transformations (XSLT). We propose a meta-model for WebML to bridge WebML to MDE. To establish such a meta-model, instead of remodelling WebML\'s meta-model from scratch, a semi-automatic approach is provided that allows generating MOF-based meta-models on the basis of DTDs. The meta-model for WebML accomplishes the following aims: first, it represents an initial step towards a transition to employ MDE techniques within the WebML design methodology. Second, the provision of a MOF-based meta-model ensures interoperability with other MDE tools. Third, it represents an important step towards a common meta-model for Web modelling in future. _ The Institution of Engineering and Technology 2007.",2007,
9,paper_12,"Customisable model transformations based on non-functional requirements",http://www.scopus.com/inward/record.url?eid=2-s2.0-51749118704&partnerID=40&md5=86ed22fecaeef136ee8a5356b562494c,"<b>Authors:</b><br/>Sterritt A., Cahill V. <br/>","The Model-to-Model (M2M) transformation stage in a Model-Driven Engineering (MDE) tool chain is used to bridge the large semantic gap between problem-domain abstractions and software artefacts. This transformation is typically specified in a closed, monolithic way. Since no two systems have identical requirements, some work has been done to create explicit support for customisation of the transformation process based on functional requirements. The same is not true for non-functional requirements. The contribution of this paper is a customizable M2M transformation process that takes as an input the users priorities, in terms of non-functional properties, to select between design trade-offs in the transformation. These trade-offs are expressed as contrasting architectural styles, which describe common patterns of interactions and constraints with well understood non-functional implications. The target of the M2M transformation is an Architecture Description Language (ADL) that can be used to express styles. Model checking tools can be used to ensure that styles are adhered to during the entire MDE process. This early work focuses on describing contrasting architectural styles that address distribution issues, such as fault tolerance. _ 2008 IEEE.",2008,
10,paper_13,"Deriving multi-agent system behavior",http://www.scopus.com/inward/record.url?eid=2-s2.0-84884544209&partnerID=40&md5=b50eb063699a17d3e7b5f71c9c8137ae,"<b>Authors:</b><br/>Harbouche A., Erradi M., Mokhtari A. <br/><b>Key words:</b><br/>Behavior; Computational independent model; Derivation; Model driven engineering; Model to model transformation <br/>","The multi-agent systems (MAS) have become a very powerful paradigm in the development of complex computer systems. The modeling of these systems can reduce this complexity during the development phases. The Model-Driven Architecture (MDA) approach can be used to resolve this problem. It allows designers to model their systems at different abstraction levels, providing them with automatic model transformations to incrementally refine abstract models into concrete ones. This paper presents a MDA approach to develop multi-agent system with the derivation of the behavior of a given system agent from its global requirements. The suggested approach is based on the definition of an appropriate requirements meta-model (Computational Independent Meta-Model CIMM) and the definition of a target design meta-model (Platform Independent Meta-model PIMM). The CIM models are specified using UML activity diagram extended with collaborations to describe the system global behavior. The agent\'s behavior model (PIM) is in the form of distributed UML state machines. Automatic model transformations between these two models have been designed in order to govern the derivation process. A real application of telediagnosis in neuroscience has been developed using this approach.",2013,
11,paper_15,"Execution of natural language requirements using state machines synthesised from Behavior Trees",http://www.scopus.com/inward/record.url?eid=2-s2.0-84865230441&partnerID=40&md5=28c4f551dfadaae37f1cee034ad9b936,"<b>Authors:</b><br/>Kim S.-K., Myers T., Wendland M.-F., Lindsay P.A. <br/><b>Key words:</b><br/>Behavior Engineering; Behavior Trees; MDE; Model Transformation; Requirements; Requirements Validation; UML State Machine <br/>","This paper defines a transformation from Behavior Tree models to UML state machines. Behavior Trees are a graphical modelling notation for capturing and formalising dynamic system behaviour described in natural language requirements. But state machines are more widely used in software development, and are required for use with many tools, such as test case generators. Combining the two approaches provides a formal path from natural language requirements to an executable model of the system. This in turn facilitates requirements validation and transition to model-driven software development methods. The approach is demonstrated by defining a mapping from Behavior Trees to UML state machines using the ATLAS Transformation Language (ATL) in the Eclipse Modeling Framework. A security-alarm system case study is used to illustrate the use of Behavior Trees and execution to debug requirements. _ 2012 Elsevier Inc. All rights reserved.",2012,
12,paper_17,"Formalising model transformation rules for UML/MOF 2",http://www.scopus.com/inward/record.url?eid=2-s2.0-45849143287&partnerID=40&md5=5cee9d4e0c070821ff1e26e86952ee49,"<b>Authors:</b><br/>Amelunxen C., Schurr A. <br/>","Model-driven software development, today\'s state-of-the-art approach to the design of software, can be applied in various domains and thus demands a variety of domain-specific modelling languages. The specification of a domain-specific modelling language\'s syntax and semantics can in turn be specified based on models, which represent the approach of metamodelling as a special form of language engineering. The latest version of the unified modelling language 2 (UML 2) and its subset the meta object facility 2 (MOF 2) provide sufficient support for metamodelling, a modelling language\'s abstract syntax. Furthermore, based on the description of the abstract syntax, a language\'s static semantics can simply be specified by the object constraint language (OCL) as UML/MOF\'s natural constraint language, whereas the description of an MOF compliant language\'s dynamic semantics is still not covered. The authors try to close this gap by integrating MOF/OCL with graph transformations for the specification of dynamic aspects of modelling languages and tools. The formalisation of such an integration is non-trivial because of the fact that UML/MOF 2 offer a rather unusual and sophisticated association concept (graph model). Although there are many approaches, which formalise graph transformations in general and first approaches that offer a precise specification of the semantics of the association concepts of UML/MOF 2, there is still a lack in bringing both together. Here, the authors close this gap by formalising graph transformations that work on a UML/MOF 2 compatible graph model. _ 2008 The Institution of Engineering and Technology.",2008,
13,paper_18,"From AADL to Timed Abstract State Machines: A verified model transformation",http://www.scopus.com/inward/record.url?eid=2-s2.0-84900826199&partnerID=40&md5=0ad3d16afd97d7f87ffb9f20bf15eb94,"<b>Authors:</b><br/>Yang Z., Hu K., Ma D., Bodeveix J.-P., Pi L., Talpin J.-P. <br/><b>Key words:</b><br/>Architecture Analysis and Design Language (AADL); Coq; Model transformation; Model-driven engineering; Semantics preservation; Timed Abstract State Machine (TASM) <br/>","Architecture Analysis and Design Language (AADL) is an architecture description language standard for embedded real-time systems widely used in the avionics and aerospace industry to model safety-critical applications. To verify and analyze the AADL models, model transformation technologies are often used to automatically extract a formal specification suitable for analysis and verification. In this process, it remains a challenge to prove that the model transformation preserves the semantics of the initial AADL model or, at least, some of the specific properties or requirements it needs to satisfy. This paper presents a machine checked semantics-preserving transformation of a subset of AADL (including periodic threads, data port communications, mode changes, and the AADL behavior annex) into Timed Abstract State Machines (TASM). The AADL standard itself lacks at present a formal semantics to make this translation validation possible. Our contribution is to bridge this gap by providing two formal semantics for the subset of AADL. The execution semantics provided by the AADL standard is formalized as Timed Transition Systems (TTS). This formalization gives a reference expression of AADL semantics which can be compared with the TASM-based translation (for verification purpose). Finally, the verified transformation is mechanized in the theorem prover Coq. _ 2014 Elsevier Inc.",2014,
14,paper_19,"From UML to ANSI-C: An eclipse-based code generation framework",http://www.scopus.com/inward/record.url?eid=2-s2.0-57649210777&partnerID=40&md5=dc890e31582356bb18bc74abf12b778e,"<b>Authors:</b><br/>Funk M., Nyen A., Lichter H. <br/><b>Key words:</b><br/>ANSI-C; Code generation; Embedded & real-time systems; UML <br/>","Model-driven engineering has recently gained broad acceptance in the field of embedded and real-time soft-ware systems. While larger embedded and real-time systems, developed e.g. in aerospace, telecommunication, or automotive industry, are quite well supported by model-driven engineering approaches based on the UML, small embedded and real-time systems, as they can for example be found in the industrial automation industry, are still handled a bit novercal. A major reason for this is that the code generation facilities, being offered by most of the UML modeling tools on the market, do indeed support C/C++ code generation in all its particulars, but neglect the generation of plain ANSI-C code. However, this would be needed for small embedded and real-time systems, which have special characteristics in terms of hard time and space constraints. Therefore we developed a framework, which allows to generate ANSI conformant C code from UML models. It is built on top of Eclipse technology, so that it can be integrated easily with available UML modeling tools. Because flexibility and customizability are important requirements, the generation process consists of a model-to-model transformation between the UML source model and an intermediate ANSI-C model, as well as a final model-to-text generation from the intermediate ANSI-C model into C code files. This approach has several advantages compared to a direct code generation strategy.",2008,
15,paper_20,"From real computational independent models to information system models: An MDE approach",http://www.scopus.com/inward/record.url?eid=2-s2.0-84885236205&partnerID=40&md5=eb35d298e364b160590073065a17525e,"<b>Authors:</b><br/>De Castro V., Mesa J.M.V., Herrmann E., Marcos E. <br/><b>Key words:</b><br/>Computational Independent Models; Information system Models; Model Driven Engineering; Model Transformations <br/>","Model Driven Engineering approaches deal with the provision of models, transformations between them and code generators to address software development. One of the main advantages of this approach is the definition of a conceptual structure where the models used by business managers and analysts can be traced towards more detailed models used by software developers. In this paper we focus on this kind of model transformations, that is, model transformations that allow us obtain behavioural models of the service-oriented information system (Platform Independent Models) from high level business models (Computational Independent Models). From our point of view, the main drawback regarding CIM to PIM transformations lies in the alignment between what we model at CIM and PIM levels, the business view in the former and the information system view in the later. All this given, in this work we analyze, by mean of a case study, how it is possible to integrate both views and therefore, how we can help software developers to take the most of the business knowledge represented in high level business models.",2008,
16,paper_21,"Generating user interfaces from conceptual models: A modeltransformation based approach",http://www.scopus.com/inward/record.url?eid=2-s2.0-84879681495&partnerID=40&md5=ddef90d1021c316aa6dd57f3ed070167,"<b>Authors:</b><br/>Pastor O. <br/><b>Key words:</b><br/>Conceptual modeling of user interface; Functional requirements; Model-based code generation; User interaction and model-driven approach <br/>","Traditionally, the Software Engineering community has been interested in defining methods and processes to develop software by specifying its data and behavior disregarding user interaction. On the other hand, the Human-Computer Interaction community has defined techniques oriented to the modeling of the interaction between the user and the system, proposing a user-oriented software construction. This paper aspires to reconcile both visions by integrating them in a whole software production process. An approach based on conceptual- schema centric software development is presented, where conceptual primitives intended to specify static, dynamic and interaction aspects are properly provided. Furthermore, Model Transformation techniques are proposed to go from the problem space, represented by the Conceptual Schema, to the solution space, represented by the corresponding final software product. This proposal is underpinned by some current MDA-based technology, which makes user-oriented, model-based software generation a reality. _ 2007 Springer.",2007,
17,paper_22,"Increasing quality in scenario modelling with model-driven development",http://www.scopus.com/inward/record.url?eid=2-s2.0-78751479998&partnerID=40&md5=6997c0285712b8a8c585373db710b0fb,"<b>Authors:</b><br/>Santos J.P., Moreira A., Araujo J., Goulao M. <br/><b>Key words:</b><br/>Model transformations; Model-driven engineering; Scenario modeling <br/>","Models, with different levels of detail, share similar abstractions that can be reused by means of model-driven techniques such as transformations. For example, scenarios are a well-known technique in requirements engineering to represent behavioral flows in a software system. When using UML, scenarios are typically represented with activity models in the early stages of software development, while sequence models are used to describe more detailed object interactions as modeling progresses. This paper defines transformation rules to automate the migration from activity to sequence models. We present a case study illustrating the application of our transformation rules. Our preliminary assessment of the impact of the benefits of using these transformations points to: (i) a reduction of around 50% in the effort building sequence models, (ii) increased traceability among models, and (iii) error prevention when migrating from different scenario notations. _ 2010 IEEE.",2010,
18,paper_24,"Model transformations to bridge concrete and abstract syntax of web rule languages",http://www.scopus.com/inward/record.url?eid=2-s2.0-77953850056&partnerID=40&md5=ab6df885f0ce090e2720867a5d804590,"<b>Authors:</b><br/>Milanovic M., Gasevic D., Giurca A., Wagner G., Lukichev S., Devedzic V. <br/><b>Key words:</b><br/>Languages; MDE; OCL; R2ML; Rules; SWRL; Syntax; Transformations <br/>","This paper presents a solution to bridging the abstract and concrete syntax of a Web rule languages by using model transforma-tions. Current specifications of Web rule languages such as Semantic Web Rule Language (SWRL) or RuleML define their abstract syntax (e.g., metamodel) and concrete syntax (e.g., XML schema) separately. Although the recent research in the area of Model-Driven Engineering (MDE) demonstrates that such a separation of two types of syntax is a good practice (due to the complexity of languages), one should also have tools that check validity of rules written in a concrete syntax with respect to the abstract syntax of the rule language. In this study, we use the REWERSE I1 Rule Markup Language (R2ML), SWRL, and Object Constraint Language (OCL), whose abstract syntax is defined by using metamodeling, while their textual concrete syntax is defined by using ei-ther XML/RDF schema or Extended Backus-Naur Form (EBNF) syntax. We bridge this gap by a bi-directional transformation defined in a model transformation language (ATLAS Transformation Language, ATL). This transformation allowed us to discover a number of issues in both web rule language metamodels and their corresponding concrete syntax, and thus make them fully compatible. This solution also enables for sharing web rules between different web rule languages.",2009,
19,paper_25,"Harvesting models from web 2.0 databases",http://link.springer.com/article/10.1007/s10270-011-0194-z,"<b>Authors:</b><br/>Oscar Díaz, Gorka Puente, Javier Luis Cánovas Izquierdo, Jesús García Molina <br/>",,2011,
20,paper_26,"Model-driven software migration into service-oriented architectures",http://www.scopus.com/inward/record.url?eid=2-s2.0-84872618488&partnerID=40&md5=cb26634b28962cf9696290ce28516fee,"<b>Authors:</b><br/>Andreas Fuhr Tassilo Horn Volker Riediger  Andreas Winter  <br/><b>Key words:</b><br/>Model-driven software development; Reengineering; Service-oriented architecture; Software migration <br/>","This paper proposes model-driven techniques to extend IBM\'s SOMA method towards migrating legacy systems into Service-Oriented Architectures (SOA). The proposal explores how graph-based querying and transformation techniques enable the integration of legacy assets into a new SOA and how these techniques can be integrated into the overall migration process. The presented approach is applied to the identification and migration of services in an open source Java software system. _ 2011 Springer-Verlag.",2013,
21,paper_27,"Model-driven transformations: From analysis to MVC 2 web model",http://www.scopus.com/inward/record.url?eid=2-s2.0-77952312321&partnerID=40&md5=d7cade38a49023fdfaff0d54a5481ad5,"<b>Authors:</b><br/>Mbarki S., Erramdani M. <br/><b>Key words:</b><br/>Meta-models; Model driven engineering; Rules transformation; Software engineering; Web applications development <br/>","Web applications have the complexity of designing, developing, maintaining, and managing. These systems have increased significantly as well. To cope with this complexity, several frameworks (supporting the MVC 2 pattern) have been elaborated. Facing this diversity and incessant improvement of Web technology, we are in need of developing a tool which is able to produce the code from analysis-level UML models. In this paper, we apply MDA approach for generating code from requirements to MVC 2 Web implementation. That is why we have developed two metamodels handling UML class diagrams and MVC 2 Web applications, then we have to set up two transformations. The first one is a PIM to PIM transformation allowing the refinement of the analysis-level class diagram. The second one is a PIM to PSM transformation for MVC 2 Web applications. _ 2009 Praise Worthy Prize S.r.l - All rights reserved.",2009,
22,paper_28,"Modgraph: A transformation engine for EMF model transformations",http://www.scopus.com/inward/record.url?eid=2-s2.0-80052557692&partnerID=40&md5=d60b3218981c9486929b03a2634fd37c,"<b>Authors:</b><br/>Buchmann T., Westfechtel B., Winetzhammer S. <br/><b>Key words:</b><br/>Code generation; EMF; Graph transformations; Model-driven development; OCL; Pattern matching <br/>","Model-driven software engineering aims at increasing productivity by replacing conventional programming with the development of high-level executable models. However, current technology focuses on structural models, while behavioral modeling is still neglected. The transformation engine ModGraph intends to fill this gap. ModGraph complements the Eclipse Modeling Framework with graphical transformation rules from which executable code is generated. An operation defined in an Ecore model is specified by a model transformation rule which is compiled into a Java method calling EMF operations. In this way, ModGraph complements the capabilities of EMF which would compile operations into empty Java methods. The net result is an environment which provides comprehensive support for executable models.",2011,
23,paper_29,"Modular JADE agents design and implementation using ASEME",http://www.scopus.com/inward/record.url?eid=2-s2.0-78649899730&partnerID=40&md5=42a478deb6775c2c3d1489f13775c4f6,"<b>Authors:</b><br/>Spanoudakis N., Moraitis P. <br/>","ASEME is an emerging Agent Oriented Software Engineering (AOSE) methodology. The Model-Driven Engineering (MDE) paradigm encourages software modelers to automate the transition of one type of software model to another and eventually the code generation process. This paper builds on previous work that describes the model-driven development of agent systems using ASEME and creating a Platform Independent Model (PIM) that adheres to the language of statecharts, the Intra-Agent Control Model. In this contribution we use the generated statecharts and show how to automatically transform them to Java programs using the Java Agent Development Framework (JADE). All agent and behaviour classes are automatically generated including the agent interaction protocols. _ 2010 IEEE.",2010,
24,paper_30,"On using inplace transformations for model co-evolution",http://www.scopus.com/inward/record.url?eid=2-s2.0-84890500589&partnerID=40&md5=1cea9cb099f8f9651cf71751ff99709c,"<b>Authors:</b><br/>Wimmer M., Kusel A., Schoenboeck J., Retschitzegger W., Schwinger W., Kappel G. <br/><b>Key words:</b><br/>Inplace transformations; Metamodel merging; Model co-evolution <br/>","Metamodel evolution and model co-evolution are considered to be essential ingredients for the successful adoption of model-driven engineering in practice. In this respect, on the one hand, dedicated co-evolution languages have been proposed for migrating models conforming to an initial metamodel to models conforming to a revised metamodel with the drawback of requiring to learn a new language. On the other hand, the employment of dedicated model-to-model transformation languages has been proposed demanding for the specification of rules for copying unchanged elements. In this paper, we propose to tackle the co-evolution problem from a di_rent viewpoint. Instead of describing the co-evolution of models as a transformation between two metamodels, we employ existing inplace transformation languages. For this, the prerequisite is to represent both language versions within one metamodel which is automatically computed by merging the initial and the revised metamodel. This ensures that the initial as well as the revised model conform to the merged meta-model, enabling the employment of inplace transformations for initializing new metamodel elements. Finally, a check-out transformation is used for eliminating model elements which are no longer covered by the revised metamodel.We demonstrate this idea by using ATL for merging the metamodels and realizing the check-out transformation. Furthermore, we discuss the ATL refinement mode for co-evolving the models.",2010,
25,paper_31,"QVT based model transformation from sequence diagram to CSP",http://www.scopus.com/inward/record.url?eid=2-s2.0-79952032701&partnerID=40&md5=ad6baf72a90f16b05acbaa256a5c948f,"<b>Authors:</b><br/>Dan L. <br/><b>Key words:</b><br/>CSP; Model transformation; QVT; Sequence diagram; XSLT <br/>","In a model driven software development paradigm, UML sequence diagrams are used for modeling the interaction view of the software. For an application with high demanding of dependability, formal verification and analysis need to be performed on the sequence diagrams. This is usually done by transforming the sequence diagrams to a well studied formalism that has effective tool support to verification and analysis. In this paper, we propose an approach for transformations from sequence diagrams to CSP processes. The transformations are implemented by using the model driven software engineering standards, such as MOF, QVT, and XSLT. For this, we design the metamodels for sequence diagrams and CSP, and a set of transformation rules are specified using the QVT graphical syntax. The transformation rules are implemented as XSLT rule-based style templates. An XSLT engine reads the XMI file of a sequence diagram produced by an UML CASE tool, and then executes the XSLT templates, outputs the CSP model as an XML file. The XML file of the CSP processes can be translated into the input of a CSP checker for verification. _ 2010 IEEE.",2010,
26,paper_33,"Rule-based model transformation for, and in simulink",http://www.scopus.com/inward/record.url?eid=2-s2.0-84902009128&partnerID=40&md5=2b54bdaf3be97a69da6119a3d8cbef0b,"<b>Authors:</b><br/>Denil J., Mosterman P.J., Vangheluwe H. <br/><b>Key words:</b><br/>Model-based design; Model-driven engineering; Model-transformation; Simulink <br/>","Over the past decade, the design of embedded systems has come to rely on models as electronic artifacts that are both analysable and executable. Such executable models are at the core of Model-Based Design. Simulink_ is a popular Model-Based Design tool that supports simulation of models in various stages of design. While Simulink supports relating the various different models used in design, the technology to do so relies on the underlying Simulink code base. Instead, this paper employs explicit models of the relations between the various different design models. In particular, a rule-based approach is presented for model-to-model transformations. The abstraction from the code base provides benefits such as a more intuitive representation and the ability to more effectively reason about the transformations. The transformation rules and schedules are designed by augmenting standard Simulink model elements (e.g., blocks) for use in model transformation based on the structured RAMification approach. The approach is illustrated by the transformation of a continuous-time model, part of an adaptive controller, to a disrete-time counterpart, which is consecutively optimized for simulation.",2014,
27,paper_36,"Traceability-based incremental model synchronization",http://www.scopus.com/inward/record.url?eid=2-s2.0-73649147046&partnerID=40&md5=1a347b952367737650c94255ccf5e481,"<b>Authors:</b><br/>Madari I., Angyal L., Lengyel L. <br/><b>Key words:</b><br/>Model synchronization; Model transformation; Trace model; Traceability <br/>","Model transformation is a crucial aspect of Model-Driven Software Development. With the help of model transformation, we can generate source code or other artifacts from software models. However, a recurring problem in software development is the fact that source and target models coexist and they evolve independently. In general, a modeled system is composed of several models that are often related to one another. Consequently, the related models will not be consistent anymore if one of them is altered in the development process. For that reason, a model synchronization method is necessiated to resolve inconsistency between the modified models. Performing synchronization manually can be an error prone task due to the number and complexity of model elements. In model-driven technologies, where processing is carried out as a series of model transformations, applying model transformations can also be a reasonable option for the reconciliation. This paper presents an approach that uses trace models and model transformations to facilitate incremental model synchronization.",2009,
28,paper_37,"Transformation of aspect-oriented requirements specifications for reactive systems into aspect-oriented design specifications",http://www.scopus.com/inward/record.url?eid=2-s2.0-80455149951&partnerID=40&md5=c1db983b086a89d1a5652be406a773ec,"<b>Authors:</b><br/>Mussbacher G., Kienzle J., Amyot D. <br/><b>Key words:</b><br/>aspects; design models; model driven engineering; requirements; scenario models <br/>","Model-driven engineering (MDE) promises faster and more reliable software development processes. A key factor of MDE is the transformation of models, allowing a software engineer to use the most appropriate modeling notation for a particular task. The earlier transformations can be applied during software development, the greater the potential cost savings. To that effect, we report on the transformation of aspect-oriented models for reactive systems development, i.e., from a scenario-based requirements model into a UML-based design model. We use Aspect-oriented Use Case Maps (AoUCM) as the requirements notation and Reusable Aspect Models (RAM) as the design notation. While AoUCM is ideally suited for the specification of the system workflow comprised of interactions between the environment and the system, RAM excels in providing a design view of system structure and defining the data dimension of the system including inputs and outputs. As the more abstract AoUCM models are transformed into more concrete RAM models, MDE ensures that the AoUCM workflow specifications do not have to be modeled again in RAM, thus avoiding a duplication of effort. We present transformation algorithms to show that an AoUCM-to-RAM mapping is indeed feasible and report on initial tool support for the transformation. _ 2011 IEEE.",2011,
29,paper_39,"Transforming an enterprise model into a use case model in business process systems",http://www.scopus.com/inward/record.url?eid=2-s2.0-84906948931&partnerID=40&md5=a42dcbb3ee484e1b2402d0d08170c603,"<b>Authors:</b><br/>Siqueira F.L., Silva P.S.M. <br/><b>Key words:</b><br/>Stakeholder requirement; Transformation; Use case <br/>","One of the responsibilities of requirements engineering is to transform stakeholder requirements into system and software requirements. For enterprise systems, this transformation must consider the enterprise context where the system will be deployed. Although there are some approaches for detailing stakeholder requirements, some of them even considering the enterprise context, this task is executed manually. Based on model-driven engineering concepts, this study proposes a semi-automatic transformation from an enterprise model to a use case model. The enterprise model is used as a source of information about the stakeholder requirements and domain knowledge, while the use case model is used as software requirements model. This study presents the source and target metamodels, a set of transformation rules, and a tool to support the transformation. An experiment analyzes the use of the proposed transformation to investigate its benefits and if it can be used in practice, from the point of view of students in the context of a requirements refinement. The results indicate that the approach can be used in practice, as it did not influence the quality of the generated use cases. However, the empirical analysis does not indicate benefits of using the transformation, even if the qualitative results were positive. _ 2014 Elsevier Inc.",2014,
30,paper_40,"Transforming an enterprise model into a use case model using existing heuristics",http://www.scopus.com/inward/record.url?eid=2-s2.0-80455145237&partnerID=40&md5=07317d6c7f00b369701d7dfbbaab5bf0,"<b>Authors:</b><br/>Siqueira F.L., Silva P.S.M., Silva P.S.M. <br/><b>Key words:</b><br/>enterprise model; requirement; specification; transformation; use case <br/>","One of the key responsibilities of Requirements Engineering is to refine requirements into specifications. Although there are some approaches for requirements refinement, this task is usually executed manually. Based on Model-Driven Engineering concepts, this study proposes a semi-automatic transformation using an enterprise model as source and a use case model as target. The underlying hypothesis is that using an enterprise model as a source it is possible to represent both the requirements and the domain knowledge that are necessary to obtain specifications. Considering this hypothesis, this study discusses the proposed transformation and a set of heuristics - found in the analysis of existing studies - using an example, executed with support of a tool. _ 2011 IEEE.",2011,
31,paper_41,"Using ATL to support Model-Driven development of RubyTL model transformations",http://www.scopus.com/inward/record.url?eid=2-s2.0-84890720068&partnerID=40&md5=ae81b13c1d25764e055e809890200b69,"<b>Authors:</b><br/>Jimenez A., Granada D., Bollati V., Vara J.M. <br/><b>Key words:</b><br/>Atlas Transformation Language (ATL); Model transformations; Model-Driven Engineering (MDE); RubyTL; Textual concrete syntax (TCS); Transformation models <br/>","Model transformations are the main artefact in any Model-Driven Engineering proposal. However, being software artefacts more effort should be dedicated to apply model-driven principles in the development of model transformations. In this context, this work presents some tooling to ease the model-driven development of RubyTL model transformations. In particular, we present a metamodel for RubyTL, a model transformation to move from high-level to RubyTL transformation models and finally a TCS injector/extractor to move from RubyTL models to RubyTL source-code and back.",2011,
32,paper_42,"Using meta-code generation to realize higher-order model transformations",http://www.scopus.com/inward/record.url?eid=2-s2.0-84887120710&partnerID=40&md5=d37d5ec6d1398ab01ea86f7ee1bd4122,"<b>Authors:</b><br/>Buchmann T., Schwagerl F. <br/><b>Key words:</b><br/>Higher-order transformations; M2M transformations; Model transformations; Model-driven development; Software product lines <br/>","Model-driven engineering is a wide-spread paradigm in modern software engineering. During the last couple of years, many tools and languages have been developed, which are especially designed for model transformations - A discipline which is needed in many model-driven engineering approaches. While most of the existing model-to-model tools and languages are tailored towards batch transformations for specific model instances, they lack support for generic transformation problems, where the metamodel is unknown beforehand. In this paper we present a two-step meta-code generation approach that derives a metamodel-specific modelto- model transformation from a model-to-text transformation. The approach has been successfully applied to the problem of product derivation in model-driven software product lines. Copyright _ 2013 SCITEPRESS.",2013,
33,paper_43,"Verification of DSMLs using graph transformation: A case study with alloy",http://www.scopus.com/inward/record.url?eid=2-s2.0-74949086320&partnerID=40&md5=3c4ba36a9c3a0e67f5b6b46d1cd6f926,"<b>Authors:</b><br/>Demirezen Z., Mernik M., Gray J., Bryant B. <br/><b>Key words:</b><br/>Activity diagram; Domain-specific modeling languages; Graph transformation systems; Model checking; Operational semantics; Verification <br/>","Domain-Specific Modeling Languages (DSMLs) enable domain experts to participate in software development tasks and to specify their own programs using domain abstractions. Many Model-Driven Engineering (MDE) platforms primarily concentrate on structural aspects of DSMLs and only provide techniques to define abstract and concrete syntax. Only a few platforms provide built-in support for specification of behavioral semantics and verification tasks. In this paper, we focus on how to specify the behavioral semantics of a DSML by a sequence of graph transformation rules. We also discuss how to transform a DSML specification into Alloy, a model checking tool. These transformations demonstrate that DSML models specified in a visual notation can be verified by means of existing model checking tools. Copyright _ 2009 ACM.",2009,
34,paper_44,"Generation of component based architecture from business processes: Model driven engineering for SOA",http://www.scopus.com/inward/record.url?eid=2-s2.0-79951826885&partnerID=40&md5=25c063972eb44e96eaee70302a27f9cc,"<b>Authors:</b><br/>Dahman K., Charoy F., Godart C. <br/><b>Key words:</b><br/>BPM; BPMN; Business process logic and IT alignment; MDD; SCA; Service engineering; SOA <br/>","Service-Oriented Architecture (SOA) has significantly enhanced inter-organizational systems enabling business flexibility, Information Technology (IT) agility, and value generation. However, building a SOA that reduces technology-driven business and leverages process management seems referring to the recurrent issues of business process logic and IT alignment. This paper presents a model-driven development approach where long-running business service composition models drive their supporting service implementation models. To progress on the successful route to a SOA engineering with minimal design decisions losses, we propose a model-to-model transformation that preserves the architectural alignment between the business process and their supporting service implementation infrastructure. The result of the transformation is a component configuration model based on a SOA. It promotes the separation of business concerns, enabling quick and localized evolutions of the IT infrastructure. _ 2010 IEEE.",2010,
35,paper_45,"Executing a standard compliant transformation model on a non-standard platform",http://www.scopus.com/inward/record.url?eid=2-s2.0-52249118811&partnerID=40&md5=c6c466783d7019d5f7aa3c65478e2797,"<b>Authors:</b><br/>Muliawan O., Van Gorp P., Keller A., Janssens D. <br/>","Model-Driven Engineering is a software development method to model applications at a high level of abstraction and introduce platform specific details automatically using model transformations. Similarly, models specified in human-readable languages can be mapped automatically onto languages that support the analysis of formal properties. In an industrial context, the transformations that automate such mappings should be able to consume input models from various commercial tools. Unfortunately, such tools tend to store models in slightly different ways, not fully compliant to standards. Additional techniques are necessary to develop transformations in a platform independent manner instead of specific ones for each modeling tool. This paper illustrates such techniques on an example related to the transformation of visual process models (UML activity diagrams) into low-level algebraic (CSP) programs that support formal verification. In turn, the platform independent and human-readable transformation model is translated into code that can transform UML inputs even when these are non-standard. _ 2008 IEEE.",2008,
36,paper_47,"A QVT-based approach for model composition application to the VUML profile",http://www.scopus.com/inward/record.url?eid=2-s2.0-55849113397&partnerID=40&md5=5f1c1fa60105fdd355ccff73f9eb30e4,"<b>Authors:</b><br/>Anwar A., Ebersold S., Nassar M., Coulette B., Kriouile A. <br/><b>Key words:</b><br/>Correspondences; Model composition; QVT-Core standard; Transformations; Translation and composition rules; Viewpoints; VUML profile <br/>","With the increasing importance of models in software development, many activities such as transformation, verification and composition are becoming crucial in the field of Model Driven Engineering (MDE). Our main objective is to propose a model-driven approach to compose design models. This approach is applied to the VUML profile that allows to analyse/design a system on the basis of functional points of view. In this paper we first describe a transformation-based composition process and then we specify transformations as a collection of QVT-Core rules implemented in ATL. The proposal is illustrated by a simple example.",2008,
37,paper_48,"Co-design of the business and software architectures: A systems engineering and model-driven method",http://www.scopus.com/inward/record.url?eid=2-s2.0-77956051529&partnerID=40&md5=79b6badce785c237b650ff0630b8f7db,"<b>Authors:</b><br/>Cui X. <br/><b>Key words:</b><br/>Business architecture; Model-driven; Software architecture design; Systems engineering <br/>","Software architecture design plays a crucial role for both the software and business success. Most of the existing methods conduct software architecture design driven by the key software requirements, facing the challenges of creating architectures from scratch and aligning with the high-level business goals. In this paper we propose the BASAD (Business And Software Architecture co-Design) method to facilitate alleviating the difficulty of software architecture design and achieving the high-level business goals. The method addresses the business and software architecture design in an integrated process from a systems engineering perspective, leveraging the SysML and UML modeling languages and the automated model transformation from the business architectures to the software architectures, so that provide pragmatic support for the architecture co-design. _ 2010 IEEE.",2010,
38,paper_49,"Model-driven approach to Agilla Agent generation",http://www.scopus.com/inward/record.url?eid=2-s2.0-84883685860&partnerID=40&md5=af44e2dc3dc133c2a7a8e08baebfe918,"<b>Authors:</b><br/>Di Marco A., Pace S. <br/><b>Key words:</b><br/>Agent; Agilla; Code generation; Model driven engineering; Model to code; Modeling; UML profile; WSN <br/>","Wireless Sensor Networks are becoming one of the most successful choices for the development and deployment of a wide range of applications, from intelligent homes to environment monitoring. Nowadays, there is a growing demand for fast development of WSN applications that adapt at run-time to changes in the context, in the available resources, and also in user requirements. In this paper we present a model-driven approach that permits to model and automatically generate Agilla Agents. We decide to target Agilla since it is an agent based platform that allows to manage adaptation without service interruptions by means of agents substitution. The proposed approach considers UML (Unified Modeling Language) as modeling language, and consists of a UML Profile to model Agilla agents and of a Model-to-Code transformation that generates Agilla code from the presented UML modeling framework. _ 2013 IEEE.",2013,
39,paper_50,"Automating test cases generation: From xtUML system models to QML test models",http://www.scopus.com/inward/record.url?eid=2-s2.0-78650951004&partnerID=40&md5=6e3ccd987af3d2804548efa6a1f811b0,"<b>Authors:</b><br/>Ciccozzi F., Cicchetti A., Siljamaki T., Kavadiya J. <br/><b>Key words:</b><br/>automatic test cases generation; model-based development; model-based testing; model-driven engineering <br/>","The scope of Model-Driven Engineering is not limited to Model-Based Development (MBD), i.e. the generation of code from system models, but involves also Model-Based Testing (MBT), which is the automatic generation of efficient test procedures from corresponding test models. Both MBD and MBT include activities such as model creation, model checking, and use of model compilers for the generation of system/test code. By reusing these common activities, the efficiency of MBT can be significantly improved for those organizations which have already adopted MBD, since one of the major efforts in MBT is the creation of test models. In this work, we propose to exploit modeling activity efforts by deriving test models from system models. In this respect, we present a case study in which the Executable and Translatable UML system models are used for automatically generating test models in the QTronic Modeling Language using horizontal model transformations. In turn, the derived artefacts can be used to produce test cases which result to be appropriate for the system under development. _ 2010 ACM.",2010,
40,paper_52,"Model based software design: Tool support for scripting in immersive environments",http://www.scopus.com/inward/record.url?eid=2-s2.0-84894421870&partnerID=40&md5=6b8c80d25879eedab1343a086ce2f663,"<b>Authors:</b><br/>Meedeniya D.A., Perera I. <br/><b>Key words:</b><br/>CPNs; Model transformation; Model-driven development (MDD); Programming in immersive environments; UML sequence diagram <br/>","We present a prototype tool developed for the transformation of scenario-based specifications. The tool intended to support model based software development, in particular modelling Platform Independent Models (PIMs) for a given scenario and the transformation of the developed model into formalisms. The tool, which we named SD2CPN since it allows to transform the models from Umfied Modelling Language UML 2 Sequence Diagrams (SDs) into Coloured Petri nets (CPNs), helps software engineers to model the complex design scenarios comfortably and enables model checking with analysis of their designed PIMs. The context domain selected for the tool usage is programming in 3 dimensional immersive environments. The SD2CPN tool is evaluated by capturing immersive environment scenarios as SDs and transforming these into CPNs that enable flexible analysis of the state-event based program modelling in the immersive environments. Although the tool is considered for system development in immersive environments the generic nature of PIM support provided make it a general purpose tool for software development irrespective of the application domain and system scenario. _ 2013 IEEE.",2013,
41,paper_54,"Using meta-model transformation to model software evolution",http://www.scopus.com/inward/record.url?eid=2-s2.0-24344440798&partnerID=40&md5=195d50e719ad0aeab5b8faaa7a94954f,"<b>Authors:</b><br/>Girba T., Favre J.-M., Ducasse S. <br/><b>Key words:</b><br/>MDA; Metamodel; Model driven engineering; Reverse engineering; Software evolution; Software history <br/>","Understanding how software systems evolve is useful from different perspectives: reverse engineering, empirical studies etc.. For an effective understanding we need an explicit meta-model. We introduce Hismo, a meta-model which is centered around the notion of history and we show how we can obtain it from a snapshot meta-model. Based on our experience in developing the Hismo reverse engineering system, we show how we can transform a snapshot meta-model in a history meta-model. _ 2005 Elsevier B.V. All rights reserved.",2005,
42,paper_60,"Constraint-Based Model Refactoring",,"<b>Authors:</b><br/>Friedrich Steimann <br/>","The UML standard specifies well-formedness rules as constraints on UML models. To be correct, refactoring of a model must take these constraintsinto account and check that they are still satisfied after a refactoring has been performed — if not, the refactoring must be refused. With constraint-based refactoring, constraint checking is replaced by constraint solving, lifting the role of constraints from permitting or denying a tentative refactoring to computing additional model changes required for the refactoring to be executable. Thus, to the degree that the semantics of a modelling language is specified using constraints, refactorings based on these constraints are guaranteed to be meaning preserving. To enable the reuse of pre-existing constraints for refactoring, we present a mapping from well-formedness rules as provided by the UML standard to constraint rules as required by constraint-based refactoring. Using these mappings, models can be refactored at no extra cost; if refactorings fail, the lack of meaning preservation points us to how the constraint-based semantic specifications of the modelling language can be improved. ",2011,
43,paper_63,"Operational Semantics of UML Activity Diagram: An Application in Project Management",,"<b>Authors:</b><br/>Syriani E, Ergin H <br/>","With its recent adoption by the International Organization for Standardization, we foresee that UML will be systematically used for object-oriented modeling in industry. UML activity diagrams have been typically used to model software and business processes. Due to its semi-formal semantics and high complexity, its advanced constructs such as expansion regions, interruptible regions, object nodes, time events, and compound activities are rarely used in practice. There has been significant work on formalizing UML activity diagrams in terms of its semantic domain: Petri net. However, none address the recent advanced constructs it offers. In this paper, we define the semantics of UML activity diagram using a rulebased model transformation. Verification and validation of the UML activity diagram model is then achieved by simulating and analyzing the Petri net model. We illustrate our technique by using an extension of UML activity diagram to facilitate project management tasks such as scheduling, cost estimation, and resource allocation.",2012,
44,paper_64,"Domain-Specific Model Transformation in Building Quantity Take-off",,"<b>Authors:</b><br/>Steel J, Drogmuller R <br/>","The two core concepts of model-driven engineering are models and model transformations. Domain-Specific Modelling has become accepted as a powerful means of providing domain experts and end users with the ability to create and manipulate models within the systems that they use. In this paper we argue that there are domains for which it is appropriate to also provide domain experts with the ability to modify and develop model transformations. One such domain is that of quantity surveying, and specifically the taking-off of quantities from a building design. We describe a language for expressing transformations between building models and bills of quantities, and its implementation within an automated quantity take-off tool, reflecting on the commonalities and differences between this language and a general-purpose model transformation language/tool.",2011,
45,paper_65,"Instant and Incremental QVT Transformation for Runtime Models",,"<b>Authors:</b><br/>Hui Song, Gang Huang, Franck Chauvel, Wei Zhang, Yanchun Sun,Weizhong Shao, and Hong Mei <br/>","Abstract. As a dynamic representation of the running system, a runtime model provides a model-based interface to monitor and control the system. A key issue for runtime models is to maintain their causal connections with the running system. That means when the systems change, the models should change accordingly, and vice versa. However, for the abstract runtime models that are heterogeneous to their target systems, it is challenging to maintain such causal connections. This paper presents a model-transformation-based approach to maintaining causal connections for abstract runtime models. We define a new instant and incremental transformation semantics for the QVT-Relational language, according to the requirements of runtime models, and develop the transformation algorithm following this semantics. We implement this approach on the mediniQVT transformation engine, and apply it to provide the runtime model for an intelligent office system named SmartLab.",2012,
46,paper_66,"From UML and OCL to Relationnal Logic and Back",,"<b>Authors:</b><br/>Mirco Kuhlmann and Martin Gogolla <br/>","Languages like UML and OCL are used to precisely model systems. Complex UML and OCL models therefore represent a crucial part of model-driven development, as they formally specify the main system properties. Consequently, creating complete and correct models is a critical concern. For this purpose, we provide a lightweight model validation method based on efficient SAT solving techniques. In this paper, we present a transformation from UML class diagram and OCL concepts into relational logic. Relational logic in turn represents the source for advanced SAT-based model instance finders like Kodkod. This paper focuses on a natural transformation approach which aims to exploit the features of relational logic as directly as possible through straitening the handling of main UML and OCL features. This approach allows us to explicitly benefit from the efficient handling of relational logic in Kodkod and to interpret found results backwards in terms of UML and OCL.",2013,
47,paper_67,"Tackling High Variability in Video Surveillance Systems through a Model Transformation Approac",,"<b>Authors:</b><br/>Mathieu Acher, Philippe Lahire, Sabine Moisan, Jean-Paul Rigault <br/>","This work explores how model-driven engineering techniques can support the configuration of systems in domains presenting multiple variability factors. Video surveillance is a good candidate for which we have an extensive experience. Ultimately, we wish to automatically generate a software component assembly from an application specification, using model to model transformations. The challenge is to cope with variability both at the specification and at the implementation levels. Our approach advocates a clear separation of concerns. More precisely, we propose two feature models, one for task specification and the other for software components. The first model can be transformed into one or several valid component configurations through step-wise specialization. This paper outlines our approach, focusing on the two feature models and their relations. We particularly insist on variability and constraint modeling in order to achieve the mapping from domain variability to software variability through model transformations.",2009,
48,paper_68,"Model-to-Metamodel Transformation for the Development of Component-Based Systems",,"<b>Authors:</b><br/>Gerd Kainz, Christian Buck Stephan Sommer and Alois Knoll <br/>","Embedded systems are a potential application area for component-based development approaches. They can be assembled from ultiple generic components that can either be application components used to realize the application logic or hardware components to provide low level hardware access. The glue code to connect these components is typically implemented using middleware or run-time systems. Nowadays great parts of the system are automatically generated and configured according to application needs by using model driven software development tools. In a model driven development process, three different kinds of developers can be identified: run-time system experts, component developers and application developers. This paper presents a multi-phase approach, which is suited to support all of these experts in an optimal way. Key idea is a multi-phase development process based on model-to-metamodel transformations connecting the different phases. The advantages of this approach are demonstrated in the context of distributed sensor / actuator systems",2010,
49,paper_69,"An Adjustable Transformation from OWL to Ecore",,"<b>Authors:</b><br/> Tirdad Rahmani, Daniel Oberle, Marco Dahms  <br/>","Although there are sufficient similarities between the W3C Web Ontology Language OWL and the software modeling language Ecore, little research has been conducted into approaches which allow software engineers to incorporate existingWeb ontologies into their familiar Ecore-based software engineering environments. This is becoming important since the number of significant Web ontologies is growing and software engineers are increasingly challenged to build software relying on such ontologies. Therefore, we propose an automatic transformation between OWL and Ecore, that is adjustable between the two extremes of a result which is simple to understand, or a result, which preserves as much as possible of the source ontology. The transformation is realized as an Eclipse plug-in and, thus, integrates seamlessly with a software developer’s familiar environment",2010,
50,paper_70,"A Metamodel-Based Approach for Automatic User Interface Generation",,"<b>Authors:</b><br/> António Miguel Rosado da Cruz, João Pascoal Faria  <br/>","One of the advantages of following a MDA-based approach in the development of interactive applications is the possibility of generating multiple platform-specific user interfaces (UI) from the same platform independent UI model. However, the effort required to create the UI model may be significant. In the case of data-intensive applications, a large part of the UI structure and functionality is closely related with the structure and functionality of the domain entities described in the domain model, and the access rules specified in the use case model. This paper presents an approach to reduce the effort required to create platform independent UI models for data intensive applications, by automatically generating an initial UI model from domain and use case models. For that purpose, UML-aligned metamodels for domain and use case models are defined, together with a MOF-based metamodel for user interface models. The transformation rules that drive the UI model generation are introduced. It is also proposed a MDA-based process for the development of data intensive interactive applications based on the proposed model architecture and transformations",2010,
51,paper_71,"UML2Alloy: A Challenging Model Transformation",,"<b>Authors:</b><br/> Kyriakos Anastasakis, Behzad Bordbar, Geri Georg, Indrakshi Ray   <br/>","Alloy is a formal language, which has been applied to modelling of systems in a wide range of application domains. It is supported by Alloy Analyzer, a tool, which allows fully automated analysis. As a result, creating Alloy code from a UML model provides the opportunity to exploit analysis capabilities of the Alloy Analyzer to discover possible design flaws at early stages of the software development. Our research makes use of model based techniques for the automated transformation of UML class diagrams with OCL constraints to Alloy code. The paper demonstrates challenging aspects of the model transformation, which originate in fundamental differences between UML and Alloy. We shall discuss some of the differences and illustrate their implications on the model transformation process. The presented approach is explained via an example of a secure e-business system.",2007,
52,paper_72,"Domain-specific discrete event modelling and simulation using graph transformation",,"<b>Authors:</b><br/> Juan de Lara, Esther Guerra, Artur Boronat, Reiko Heckel, Paolo Torrini  <br/>","Graph transformation is being increasingly used to express the semantics of domain-specific visual languages since its graphical nature makes rules intuitive. However, many application domains require an explicit handling of time to accurately represent the behaviour of a real system and to obtain useful simulation metrics to measure throughputs, utilization times and average delays. Inspired by the vast knowledge and experience accumulated by the discrete event simulation community, we propose a novel way of adding explicit time to graph transformation rules. In particular, we take the event scheduling discrete simulation world view and provide rules with the ability to schedule the occurrence of other rules in the future. Hence, our work combines standard, efficient techniques for discrete event simulation (based on the handling of a future event set) and the intuitive, visual nature of graph transformation. Moreover, we show how our formalism can be used to give semantics to other timed approaches and provide an implementation on top of the rewriting logic system Maude",2012,
53,paper_73,"Adapting transformations to metamodel changes via external transformation composition",,"<b>Authors:</b><br/> Kelly Garcés, Juan M. Vara, Frédéric Jouault, Esperanza Marcos   <br/>","Evolution is inherent to software systemsbecause of the rapid improvement of technologies and business logic. As a software development paradigm, model driven engineering (MDE) is also affected by this problem. More concretely, being metamodels the cornerstone of MDE, their evolution impacts the rest of software artefacts involved in a development process, i.e., models and transformations. The influence over models has been tackled and partially solved in previous works. This paper focuses on the impact over transformations. We propose an approach to adapt transformations by means of external transformation composition. That is, we chain impacted transformations to particular adaptation transformations which deal with either refactoring/destruction changes or construction changes. Our approach semi-automatically generates such transformations by using the AtlanMod matching language, a DSL to define model matching strategies. To provide with a proof of concept for our proposal, we adapt transformations written in terms of object-relational database metamodels when such metamodels evolve in time.",2012,
54,paper_74,"Extracting models from source code in software modernization",,"<b>Authors:</b><br/>Javier Luis Cánovas Izquierdo, Jesús García Molina <br/>","Model-driven software modernization is a discipline in which model-driven development (MDD) techniques are used in the modernization of legacy systems. When existing software artifacts are evolved, they must be transformed into models to apply MDD techniques such as model transformations. Since most modernization scenarios (e.g., application migration) involve dealing with code in general-purpose programming languages (GPL), the extraction of models from GPL code is an essential task in a model-based modernization process. This activity could be performed by tools to bridge grammarware and MDD technical spaces, which is normally carried out by dedicated parsers. Grammar-to-Model Transformation Language (Gra2MoL) is a domain-specific language (DSL) tailored to the extraction of models from GPL code. This DSL is actually a text-to-model transformation language which can be applied to any code conforming to a grammar. Gra2MoL aims to reduce the effort needed to implement grammarware-MDD bridges, since building dedicated parsers is a complex and time-consuming task. Like ATL and RubyTL languages, Gra2MoL incorporates the binding concept needed to write mappings between grammar elements and metamodel elements in a simple declarative style. The language also provides a powerful query language which eases the retrieval of scattered information in syntax trees. Moreover, it incorporates extensibility and grammar reuse mechanisms. This paper describes Gra2MoL in detail and includes a case study based on the application of the language in the extraction of models from Delphi code",2012,
55,paper_75,"Synchronizing concurrent model updates based on bidirectional transformation",,"<b>Authors:</b><br/> Yingfei Xiong, Hui Song, Zhenjiang Hu, Masato Takeichi  <br/>","Model-driven software development often involves several related models. When models are updated, the updates need to be propagated across all models to make them consistent. A bidirectional model transformation keeps two models consistent by updating one model in accordance with the other. However, it does not work when the two models are modified at the same time. In this paper we first examine the requirements for synchronizing concurrent updates. We view a synchronizer for concurrent updates as a function taking the two original models and the two updated models as input, and producing two new models where the updates are synchronized. We argue that the synchronizer should satisfy three properties that we define to ensure a reasonable synchronization behavior. We then propose a new algorithm to wrap any bidirectional transformation into a synchronizer with the help of model difference approaches. We show that synchronizers produced by our algorithm are ensured to satisfy the three properties if the bidirectional transformation satisfies the correctness property and the hippocraticness property. We also show that the history ignorance property contributes to the symmetry of our algorithm. An implementation of our algorithm shows that it worked well in a practical runtime management framework",2011,
56,paper_76,"Verifying workflow processes: a transformation-based approach",,"<b>Authors:</b><br/> Haiping Zha, Wil M. P. van der Aalst, Jianmin Wang, Lijie Wen, Jiaguang Sun  <br/>","Workflow modeling is a challenging activity and designers are likely to introduce errors, especially in complex industrial processes. Effective process verification is essential at design time because the cost of fixing errors during runtime is substantially higher. However, most user-oriented workflow modeling languages lack formal semantics that hinders such verification. In this paper, we propose a generic approach based on the model transformation to verify workflow processes. The model transformation includes two steps: first, it formalizes the desirable semantics of each modeling element; secondly, it translates a workflow process with clear semantics to an equivalent Petri net. Thus, we can verify the original workflow process using existing Petri net theory and analysis tools. As a comprehensive case study, verifying workflow processes in an industrial modeling language (TiPLM) is presented. Experimental evaluations on verifying real-world business processes validate our approach.",2010,
57,paper_77,"On challenges of model transformation from UML to Alloy",,"<b>Authors:</b><br/> Kyriakos Anastasakis, Behzad Bordbar, Geri Georg, Indrakshi Ray   <br/>","The Unified Modeling Language (UML) is the de facto language used in the industry for software specifications. Once an application has been specified, Model Driven Architecture (MDA) techniques can be applied to generate code from such specifications. Since implementing a system based on a faulty design requires additional cost and effort, it is important to analyse the UML models at earlier stages of the software development lifecycle. This paper focuses on utilizing MDA techniques to deal with the analysis of UML models and identify design faults within a specification. Specifically, we show how UML models can be automatically transformed into Alloy which, in turn, can be automatically analysed by the Alloy Analyzer. The proposed approach relies on MDA techniques to transform UML models to Alloy. This paper reports on the challenges of the model transformation from UML class diagrams and OCL to Alloy. Those issues are caused by fundamental differences in the design philosophy of UML and Alloy. To facilitate better the representation of Alloy concepts in the UML, the paper draws on the lessons learnt and presents a UML profile for Alloy",2008,
58,paper_78,"Code generation by model transformation: a case study in transformation modularity",,"<b>Authors:</b><br/> Zef Hemel, Lennart C. L. Kats, Danny M. Groenewegen, Eelco Visser  <br/>","The realization of model-driven software development requires effective techniques for implementing code generators for domain-specific languages. This paper identifies techniques for improving separation of concerns in the implementation of generators. The core technique is code generation by model transformation, that is, the generation of a structured representation (model) of the target program instead of plain text. This approach enables the transformation of code after generation, which in turn enables the extension of the target language with features that allow better modularity in code generation rules. The technique can also be applied to ‘internal code generation’ for the translation of high-level extensions of a DSL to lower-level constructs within the same DSL using model-to-model transformations. This paper refines our earlier description of code generation by model transformation with an improved architecture for the composition of model-to-model normalization rules, solving the problem of combining type analysis and transformation. Instead of coarse-grained stages that alternate between normalization and type analysis, we have developed a new style of type analysis that can be integrated with normalizing transformations in a fine-grained manner. The normalization strategy has a simple extension interface and integrates non-local, context-sensitive transformation rules. We have applied the techniques in a realistic case study of domain-specific language engineering, i.e. the code generator for WebDSL, using Stratego, a high-level transformation language that integrates model-to-model, model-to-code, and code-to-code transformations.",2009,
59,paper_79,"Transformation of UML and OCL Models into Filmstrip Models",,"<b>Authors:</b><br/>Hilken, F.; Hamann, L.; Gogolla, M.  <br/>",,2014,
60,paper_80,"Triple Graph Grammars in the Large for Translating Satellite Procedures",,"<b>Authors:</b><br/>Hermann, F. (1); Gottmann, S. (1); Nachtigall, N. (1); Ehrig, H. (2); Braatz, B. (1); Morelli, G. (3); Pierre, A. (3); Engel, T. (1); Ermel, C. (2)  <br/>",,2014,
61,paper_81,"Domain-Specific Optimization in Digital Forensics",,"<b>Authors:</b><br/>van den Bos, J. (1); van der Storm, T. (1)  <br/>",,2012,
62,paper_83,"Translational Semantics of a Co-evolution Specific Language with the EMF Transformation Virtual Machine",,"<b>Authors:</b><br/>Wagelaar, D. (1); Iovino, L. (2); Di Ruscio, D. (2); Pierantonio, A. (2)  <br/>",,2012,
63,paper_84,"Bidirectional transformation of model-driven spreadsheets",,"<b>Authors:</b><br/>Cunha, J. (1); Fernandes, J.P. (1); Mendes, J. (1); Pacheco, H. (1); Saraiva, J. (1)  <br/>",,2012,
64,paper_86,"Programmed graph rewriting with time for simulation-based design",,"<b>Authors:</b><br/>Syriani, E. (1); Vangheluwe, H. (1)  <br/>",,2008,
65,paper_88,"Implementing Business Process Recovery Patterns through QVT Transformations",,"<b>Authors:</b><br/>Pérez-Castillo, R. (1); de Guzmain, I.G. (1); Piattini, M. (1)  <br/>",,2010,
66,paper_89,"From Sequence Diagrams to State Machines by Graph Transformation",,"<b>Authors:</b><br/>GrÃ¸nmo, R. (1); MÃ¸ller-Pedersen, B. (1)  <br/>",,2010,
67,paper_91,"Transforming process algebra models into UML state machines: bridging a semantic gap?",,"<b>Authors:</b><br/>van Amstel, M.F. (1); van den Brand, M.G.J. (1); Protic, Z. (1); Verhoeff, T. (1)  <br/>",,2008,
68,paper_92,"From Spreadsheets to Relational Databases and Back",,"<b>Authors:</b><br/>Jácome Cunha, João Saraiva, Joost Visser <br/>",,2009,
69,paper_100,"Transformation as Search",,"<b>Authors:</b><br/>Mathias Kleiner2, Marcos Didonet Del Fabro1, and Davi De Queiroz Santos1 <br/>",,2013,
70,paper_101,"Bridging the Gap between Requirements and Aspect State Machines to Support Non-functional Testing: Industrial Case Studies",http://link.springer.com/chapter/10.1007%2F978-3-642-31491-9_12,"<b>Authors:</b><br/>Tao Yue, Shaukat Ali <br/>",,2012,
71,paper_103,"Normalizing Heterogeneous Service Description Models with Generated QVT Transformations",http://link.springer.com/chapter/10.1007%2F978-3-319-09195-2_12,"<b>Authors:</b><br/>Simon Schwichtenberg,  Christian Gerth , Zille Huma ,Gregor Engels  <br/>",,2014,
72,paper_104,"Translating OCL to Graph Patterns",http://link.springer.com/chapter/10.1007%2F978-3-319-11653-2_41,"<b>Authors:</b><br/>Gábor Bergmann <br/>",,2014,
73,paper_106,"Transformation Rules for Translating Business Rules to OCL Constraints",http://link.springer.com/chapter/10.1007%2F978-3-642-21470-7_10,"<b>Authors:</b><br/>Imran S. Bajwa,Mark G. Lee  <br/>",,2011,
74,paper_107,"An Automated Approach to Transform Use Cases into Activity Diagrams",http://link.springer.com/chapter/10.1007%2F978-3-642-13595-8_26,"<b>Authors:</b><br/> Tao Yue, Lionel C. Briand, Yvan Labiche  <br/>",,2010,
75,paper_109,"Automated Transition from Use Cases to UML State Machines to Support State-Based Testing",http://link.springer.com/chapter/10.1007%2F978-3-642-21470-7_9,"<b>Authors:</b><br/>Tao Yue,Shaukat Ali,Lionel Briand  <br/>",,2011,
76,paper_110,"Model Transformations for Migrating Legacy Models: An Industrial Case Study",http://link.springer.com/chapter/10.1007%2F978-3-642-31491-9_9,"<b>Authors:</b><br/>Gehan M. K. Selim,Shige Wang,James R. Cordy,Juergen Dingel <br/>",,2012,
77,paper_111,"BOB the Builder: A Fast and Friendly Model-to-PetriNet Transformer",http://link.springer.com/chapter/10.1007%2F978-3-642-31491-9_31,"<b>Authors:</b><br/>Ulrich Winkler,Mathias Fritzsche,Wasif Gilani,Alan Marshall  <br/>",,2012,
78,paper_112,"Code Generation for UML 2 Activity Diagrams",http://link.springer.com/chapter/10.1007%2F978-3-642-21470-7_15,"<b>Authors:</b><br/>Dominik Gessenharter,Martin Rauscher <br/>",,2011,
79,paper_116,"Towards Model Driven Tool Interoperability: Bridging Eclipse and Microsoft Modeling Tools",http://link.springer.com/chapter/10.1007/978-3-642-13595-8_5,"<b>Authors:</b><br/> Hugo Brunelière,Jordi Cabot,Cauê Clasen,Frédéric Jouault,Jean Bézivin  <br/>",,2010,
80,paper_117,"Model-Driven Engineering of Machine Executable Code",http://link.springer.com/chapter/10.1007/978-3-642-13595-8_10,"<b>Authors:</b><br/>Michael Eichberg,Martin Monperrus,Sven Kloppenburg,Mira Mezini <br/>",,2010,
81,paper_118,"Translation of QVT Relations into QVT Operationnal Mappings",,"<b>Authors:</b><br/>Raphael Romeikat, Stephan Roser, Pascal Mullender, and Bernhard Bauer <br/>",,2008,
82,paper_119,"Rewriting Queries by Means of Model Transformations from SPARQL to OQL and Vice-Versa",,"<b>Authors:</b><br/>Guillaume Hillairet, Frédéric Bertrand, and Jean Yves Lafaye <br/>",,2009,
